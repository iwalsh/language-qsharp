"scopeName": "source.qsharp"
"name": "Q#"
"fileTypes": [
  "qs"
],
"patterns": [
  { "include": "#comment" },
  { "include": "#statement" },
  { "include": "#storage-modifiers" },  # TODO: probably shouldn't be at top-level
  { "include": "#literal" }  # TODO: shouldn't be at top-level
  { "include": "#punctuation-semicolon" }
],
"repository": {
  "comment": {
    "patterns": [
      {
        "begin": "(^\\s+)?(?=//)",
        "beginCaptures": {
          "1": {
            "name": "punctuation.whitespace.comment.leading.qsharp"
          }
        },
        "end": "(?=$)",
        "patterns": [
          {
            # Double-slash comments
            "name": "comment.line.double-slash.qsharp",
            "begin": "(?<!/)//(?!/)",
            "beginCaptures": {
              "0": {
                "name": "punctuation.definition.comment.qsharp"
              }
            },
            "end": "(?=$)"
          },
          {
            # Documentation (triple-slash) comments
            "name": "comment.block.documentation.qsharp",
            "begin": "(?<!/)///(?!/)",
            "beginCaptures": {
              "0": {
                "name": "punctuation.definition.comment.qsharp"
              }
            },
            "end": "(?=$)",
            "patterns": [
              { "include": "#documentation-comment" }
            ]
          }
        ]
      }
    ]
  },
  "documentation-comment": {
    # TODO: Is there a way to include the Markdown grammar here?
    "patterns": [
      { "include": "#documentation-comment-header" },
      { "include": "#documentation-comment-cross-reference" }
    ]
  },
  "documentation-comment-header": {
    "name": "markup.heading.1.md.qsharp"
    "begin": "\\G\\s*(#)\\s+",
    "beginCaptures": {
      "1": {
        "name": "punctuation.definition.comment-header.qsharp"
      }
    }
    "end": "\\s*(?=$)"
  },
  "documentation-comment-cross-reference": {
    "name": "markup.underline.link.qsharp"
    "begin": "@\"",
    "beginCaptures": {
      "0": {
        "name": "punctuation.definition.cross-reference.begin.qsharp"
      }
    }
    "end": "\"",
    "endCaptures": {
      "0": {
        "name": "punctuation.definition.cross-reference.end.qsharp"
      }
    }
  },
  "expression": {
    "patterns": [
      { "include": "#interpolated-string" },
      { "include": "#literal" },
      { "include": "#expression-operators" },
      { "include": "#identifier" },
      { "include": "#parenthesized-expression" }
    ]
  },
  "statement": {
    "patterns": [
      { "include": "#comment" },
      { "include": "#return-statement" },
      { "include": "#if-statement" },
      { "include": "#else-part" },
      { "include": "#for-statement" },
      { "include": "#repeat-statement" },
      { "include": "#until-statement" },
      { "include": "#fail-statement" },
      { "include": "#let-statement" },
      { "include": "#mutable-statement" },
      { "include": "#set-statement" },
      { "include": "#block" }
    ]
  },
  "return-statement": {
    "begin": "(?<!\\.)\\b(return)\\b",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.flow.return.qsharp"
      }
    },
    "end": "(?=;)"
    # TODO: inner patterns
    "patterns": [
      { "include": "#ref-modifier" },
      { "include": "#expression" }
    ]
  },
  "if-statement": {
    "begin": "(?<!\\.)\\b(if)|(elif)\\b\\s*(?=\\()",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.conditional.if.qsharp"
      },
      "2": {
        "name": "keyword.control.conditional.elif.qsharp"
      },
    },
    "end": "(?<=\\})",
    "patterns": [
      {
        "begin": "\\(",
        "beginCaptures": {
          "0": {
            "name": "punctuation.parenthesis.open.qsharp"
          }
        },
        "end": "\\)",
        "endCaptures": {
          "0": {
            "name": "punctuation.parenthesis.close.qsharp"
          }
        },
        "patterns": [
          { "include": "#expression" }
        ]
      },
      { "include": "#statement" }
    ]
  },
  "else-part": {
    "begin": "(?<!\\.)\\b(else)\\b",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.conditional.else.qsharp"
      }
    },
    "end": "(?<=\\})",
    "patterns": [
      { "include": "#statement" }
    ]
  },
  "for-statement": {
    "begin": "(?<!\\.)\\b(for)\\b\\s*(?=\\()",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.loop.for.qsharp"
      }
    },
    "end": "(?<=\\})", # TODO: No semicolon termination?
    "patterns": [
      {
        "begin": "\\(",
        "beginCaptures": {
          "0": {
            "name": "punctuation.parenthesis.open.qsharp"
          }
        },
        "end": "\\)",
        "endCaptures": {
          "0": {
            "name": "punctuation.parenthesis.close.qsharp"
          }
        },
        "patterns": [
          {
            # TODO: test thoroughly; compare C# `foreach`
            "match": "\\s*([_[:alpha:]][_[:alnum:]]*)\\s+(in)\\s+",
            "captures": {
              "1": {
                "name": "entity.name.variable.local.qsharp"
              },
              "2": {
                "name": "keyword.control.loop.in.qsharp"
              },
              # "3": {
              # # TODO: a capture for the range expression
              # }
              # TODO: a pattern for the statement block (loop body)?
            }
          }
        ]
      },
    ]
  },
  "repeat-statement": {
    "begin": "(?<!\\.)\\b(repeat)\\b",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.loop.repeat.qsharp"
      }
    },
    "end": "(?=;|})",  # TODO: should semicolons be allowed?
    "patterns": [
      { "include": "#statement" }
    ]
  },
  "until-statement": {
    "begin": "(?<!\\.)\\b(until)\\b\\s*",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.loop.until.qsharp"
      }
    },
    "end": "(?<!\\.)\\b(fixup)\\b\\s*",  # TODO: what about the fixup block?
    "endCaptures": {
      "1": {
        # TODO: Should `fixup` be captured in its own statement, "begin"?
        "name": "keyword.control.loop.fixup.qsharp"
      }
    }
    "patterns": [
      { "include": "#expression" } # TODO: enforce boolean expression?
    ]
  },
  "fail-statement": {
    "begin": "(?<!\\.)\\b(fail)\\b",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.flow.fail.qsharp"
      }
    },
    "end": "(?=;)",
    "patterns": [
      { "include": "#expression" }
    ]
  },
  "let-statement": {
    # FIXME: Needs to allow tuple-deconstruction assignment
    "begin": "(?x)\n\\b(let)\\b\\s*\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(=)\\s*",
    "beginCaptures": {
      "1": {
        "name": "keyword.binding.let.qsharp"
      },
      "2": {
        # TODO: Should this be "variable.other.readonly.qsharp"?
        "name": "entity.name.variable.local.qsharp"
      },
      "3": {
        "name": "keyword.operator.assignment.qsharp"
      }
    },
    "end": "(?=;|\\))",
    # TODO: Need endCaptures for the semicolon?
    "patterns": [
      { "include": "#expression" }
    ]
  },
  "mutable-statement": {
    "begin": "(?x)\n\\b(mutable)\\b\\s*\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(=)\\s*",
    "beginCaptures": {
      "1": {
        "name": "keyword.binding.mutable.qsharp"
      },
      "2": {
        # TODO: Should this be "variable.other.readwrite.qsharp"?
        "name": "entity.name.variable.local.qsharp"
      },
      "3": {
        "name": "keyword.operator.assignment.qsharp"
      }
    },
    "end": "(?=;|\\))",
    # TODO: Need endCaptures for the semicolon?
    "patterns": [
      { "include": "#expression" }
    ]
  },
  "set-statement": {
    "begin": "(?x)\n\\b(set)\\b\\s*\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(=)\\s*",
    "beginCaptures": {
      "1": {
        "name": "keyword.binding.set.qsharp"
      },
      "2": {
        # TODO: Should this be "variable.other.readwrite.qsharp"?
        "name": "entity.name.variable.local.qsharp"
      },
      "3": {
        "name": "keyword.operator.assignment.qsharp"
      }
    },
    "end": "(?=;|\\))",
    # TODO: Need endCaptures for the semicolon?
    "patterns": [
      { "include": "#expression" }
    ]
  },
  "block": {
    "begin": "\\{",
    "beginCaptures": {
      "0": { "name": "punctuation.curlybrace.open.qsharp" }
    },
    "end": "\\}",
    "endCaptures": {
      "0": { "name": "punctuation.curlybrace.close.qsharp" }
    },
    "patterns": [
      {
        "include": "#statement"
      }
    ]
  }
  "storage-modifiers": {
    "patterns": [
      # TODO: are these really "storage modifiers?"
      {
        "name": "storage.modifiers.new.qsharp",
        "match": "(?<!\\.)\\b(new)\\b"
      }
    ]
  },
  "parenthesized-expression": {
    "begin": "\\(",
    "beginCaptures": {
      "0": { "name": "punctuation.parenthesis.open.qsharp" }
    },
    "end": "\\)",
    "endCaptures": {
      "0": { "name": "punctuation.parenthesis.close.qsharp" }
    },
    "patterns": [
      { "include": "#expression" }
    ]
  },
  "identifier": {
    # TODO: should this be "entity.name.variable.local.qsharp"?
    "name": "variable.other.readwrite.qsharp",
    "match": "[_[:alpha:]][_[:alnum:]]*"
  },
  "literal": {
    "patterns": [
      { "include": "#boolean-literal" },
      { "include": "#numeric-literal" },
      { "include": "#string-literal" },
      { "include": "#tuple-literal" }
    ]
  },
  "boolean-literal": {
    "patterns": [
      {
        "name": "constant.language.boolean.true.qsharp",
        "match": "(?<!\\.)\\btrue\\b"
      },
      {
        "name": "constant.language.boolean.false.qsharp",
        "match": "(?<!\\.)\\bfalse\\b"
      }
    ]
  },
  "numeric-literal": {
    "patterns": [
      # TODO: is uppercase "X" recognized for hex in Q#?
      {
        "name": "constant.numeric.hex.qsharp",
        "match": "\\b0(x|X)[0-9a-fA-F_]+(U|u)?\\b"
      }
      # TODO: Are "f" and "m" supported in qsharp?
      {
        "name": "constant.numeric.decimal.qsharp",
        "match": "\\b([0-9_]+)?\\.[0-9_]+((e|E)[0-9]+)?(F|f|M|m)?\\b"
      },
      {
        "name": "constant.numeric.decimal.qsharp",
        "match": "\\b[0-9_]+(e|E)[0-9_]+(F|f|M|m)?\\b"
      },
      {
        "name": "constant.numeric.decimal.qsharp",
        "match": "\\b[0-9_]+(F|f|D|d|M|m)\\b"
      },
      # TODO: Is the "u" suffix supported in Q#?
      {
        "name": "constant.numeric.decimal.qsharp",
        "match": "\\b[0-9_]+(U|u)?\\b"
      }
    ]
  },
  "string-literal": {
    "name": "string.quoted.double.qsharp",
    "begin": "(?<!\$)\"",
    "beginCaptures": {
      "0": {
        "name": "punctuation.definition.string.begin.qsharp"
      }
    },
    "end": "(\")|((?:[^\\\\\\n])$)",
    "endCaptures": {
      "1": {
        "name": "punctuation.definition.string.end.qsharp"
      },
      "2": {
        "name": "invalid.illegal.newline.qsharp"
      }
    },
    "patterns": [
      { "include": "#string-character-escape" }
    ]
  },
  "string-character-escape": {
    "name": "constant.character.escape.qsharp",
    "match": "\\\\."
  },
  "interpolated-string": {
    "name": "string.quoted.double.qsharp",
    "begin": "\\$\"",
    "beginCaptures": {
      "0": {
        "name": "punctuation.definition.string.begin.qsharp"
      }
    },
    "end": "(\")|((?:[^\\\\\\n])$)",
    "endCaptures": {
      "1": {
        "name": "punctuation.definition.string.end.qsharp"
      },
      "2": {
        "name": "invalid.illegal.newline.qsharp"
      }
    },
    "patterns": [
      { "include": "#string-character-escape" },
      { "include": "#interpolation" }
    ]
  },
  "interpolation": {
    "name": "meta.interpolation.qsharp",
    "begin": "(?<=[^\\{])((?:\\{\\{)*)(\\{)(?=[^\\{])",
    "beginCaptures": {
      "1": {
        "name": "string.quoted.double.qsharp"
      },
      "2": {
        "name": "punctuation.definition.interpolation.begin.qsharp"
      }
    },
    "end": "\\}",
    "endCaptures": {
      "0": {
        "name": "punctuation.definition.interpolation.end.qsharp"
      }
    },
    "patterns": [
      { "include": "#expression" }
    ]
  },
  "tuple-literal": {
    "begin": "(\\()(?=.*[:,])", # TODO: lookahead unnecessary?
    "beginCaptures": {
      "1": { "name": "punctuation.parenthesis.open.qsharp" }
    },
    "end": "\\)",
    "endCaptures": {
      "0": { "name": "punctuation.parenthesis.close.qsharp" }
    },
    "patterns": [
      {
        "include": "#expression"
      },
      {
        "include": "#punctuation-comma"
      }
    ]
  },
  "expression-operators": {
    "patterns": [
      {
        "match": "(?<!=)(=)(?!=)"
        "captures": {
          "1": { "name": "keyword.operator.assignment.qsharp" }
        }
      },
      { "include": "#arithmetic-operators" },
      { "include": "#logical-operators" },
      { "include": "#comparison-operators" },
      { "include": "#relational-operators" },
      { "include": "#bitwise-operators" }
    ]
  },
  "arithmetic-operators": {
    "patterns": [
      {
        "name": "keyword.operator.arithmetic.addition.qsharp",
        "match": "\\+"
      },
      {
        "name": "keyword.operator.arithmetic.subtraction.qsharp",
        "match": "-"
      },
      {
        "name": "keyword.operator.arithmetic.multiplication.qsharp",
        "match": "\\*"
      },
      {
        "name": "keyword.operator.arithmetic.division.qsharp",
        "match": "/"
      },
      {
        "match": "(?<!\\^)(\\^)(?!\\^)"
        "captures": {
          "1": { "name": "keyword.operator.arithmetic.exponentiation.qsharp" }
        }
      },
      {
        "name": "keyword.operator.arithmetic.modulo.qsharp",
        "match": "%"
      }
    ]
  }
  "logical-operators": {
    "patterns": [
      {
        "match": "(?<!&)(&&)(?!&)"
        "captures": {
          "1": { "name": "keyword.operator.logical.and.qsharp" }
        }
      },
      {
        "match": "(?<!\\|)(\\|\\|)(?!\\|)"
        "captures": {
          "1": { "name": "keyword.operator.logical.or.qsharp" }
        }
      },
      {
        "match": "(!)(?!\\=)"
        "captures": {
          "1": { "name": "keyword.operator.logical.not.qsharp" }
        }
      }
    ]
  },
  "comparison-operators": {
    "patterns": [
      {
        "name": "keyword.operator.comparison.equals.qsharp"
        "match": "\\=\\="
      },
      {
        "name": "keyword.operator.comparison.not-equals.qsharp"
        "match": "!\\="
      }
    ]
  },
  "relational-operators": {
    "patterns": [
      {
        "name": "keyword.operator.relational.less-than-or-equal-to.qsharp"
        "match": "<\\="
      },
      {
        "name": "keyword.operator.relational.greater-than-or-equal-to.qsharp"
        "match": ">\\="
      },
      {
        "match": "(?<!\\<)(<)(?!\\<|=)"
        "captures": {
          "1": { "name": "keyword.operator.relational.less-than.qsharp" }
        }
      },
      {
        "match": "(?<!\\>)(>)(?!\\>|=)"
        "captures": {
          "1": { "name": "keyword.operator.relational.greater-than.qsharp" }
        }
      }
    ]
  }
  "bitwise-operators": {
    "patterns": [
      {
        "before": "(?<!\\&)",  # Negative lookbehind `&`
        "end": "(?!\\&)",  # Negative lookahead `&`
        "name": "keyword.operator.bitwise.and.qsharp"
        "match": "&&&"
      },
      {
        "before": "(?<!\\|)",  # Negative lookbehind `|`
        "end": "(?!\\|)",  # Negative lookahead `|`
        "name": "keyword.operator.bitwise.or.qsharp"
        "match": "\\|\\|\\|"
      },
      {
        "before": "(?<!\\~)",  # Negative lookbehind `~`
        "end": "(?!\\~)",  # Negative lookahead `~`
        "name": "keyword.operator.bitwise.complement.qsharp"
        "match": "~~~"
      },
      {
        "before": "(?<!\\^)",  # Negative lookbehind `^`
        "end": "(?!\\^)",  # Negative lookahead `^`
        "name": "keyword.operator.bitwise.xor.qsharp"
        "match": "\\^\\^\\^"
      },
      {
        "before": "(?<!\\<)",  # Negative lookbehind `<`
        "end": "(?!\\<)",  # Negative lookahead `<`
        "name": "keyword.operator.bitwise.shift.left.qsharp"
        "match": "<<<"
      },
      {
        "before": "(?<!\\<)",  # Negative lookbehind `<`
        "end": "(?!\\<)",  # Negative lookahead `<`
        "name": "keyword.operator.bitwise.shift.right.qsharp"
        "match": ">>>"
      }
    ]
  },
  "punctuation-comma": {
    "name": "punctuation.separator.comma.qsharp",
    "match": ","
  },
  "punctuation-semicolon": {
    "name": "punctuation.terminator.statement.qsharp",
    "match": ";"
  }
}
