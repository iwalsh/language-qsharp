"scopeName": "source.qsharp"
"name": "Q#"
"fileTypes": [
  "qs"
],
"patterns": [
  {
    "include": "#comment"
  },
  {
    "include": "#statement"
  },
  {
    "include": "#storage-modifiers"  # TODO: probably shouldn't be at top-level
  }
],
"repository": {
  "comment": {
    "patterns": [
      {
        "begin": "(^\\s+)?(?=//)",
        "beginCaptures": {
          "1": {
            "name": "punctuation.whitespace.comment.leading.qsharp"
          }
        },
        "end": "(?=$)",
        "patterns": [
          {
            # Double-slash comments
            "name": "comment.line.double-slash.qsharp",
            "begin": "(?<!/)//(?!/)",
            "beginCaptures": {
              "0": {
                "name": "punctuation.definition.comment.qsharp"
              }
            },
            "end": "(?=$)"
          },
          {
            # Documentation (triple-slash) comments
            "name": "comment.block.documentation.qsharp",
            "begin": "(?<!/)///(?!/)",
            "beginCaptures": {
              "0": {
                "name": "punctuation.definition.comment.qsharp"
              }
            },
            "end": "(?=$)",
            "patterns": [
              {
                "include": "#documentation-comment"
              }
            ]
          }
        ]
      }
    ]
  },
  "documentation-comment": {
    # TODO: Is there a way to include the Markdown grammar here?
    "patterns": [
      {
        "include": "#documentation-comment-header"
      },
      {
        "include": "#documentation-comment-cross-reference"
      }
    ]
  },
  "documentation-comment-header": {
    "name": "markup.heading.1.md.qsharp"
    "begin": "\\G\\s*(#)\\s+",
    "beginCaptures": {
      "1": {
        "name": "punctuation.definition.comment-header.qsharp"
      }
    }
    "end": "\\s*(?=$)"
  },
  "documentation-comment-cross-reference": {
    "name": "markup.underline.link.qsharp"
    "begin": "@\"",
    "beginCaptures": {
      "0": {
        "name": "punctuation.definition.cross-reference.begin.qsharp"
      }
    }
    "end": "\"",
    "endCaptures": {
      "0": {
        "name": "punctuation.definition.cross-reference.end.qsharp"
      }
    }
  },
  "statement": {
    "patterns": [
      {
        "include": "#comment"
      },
      {
        "include": "#return-statement"
      }
      {
        "include": "#if-statement"
      },
      {
        "include": "#else-part"
      },
      {
        "include": "#for-statement"
      },
      {
        "include": "#repeat-statement"
      },
      {
        "include": "#until-statement"
      },
      {
        "include": "#fail-statement"
      }
    ]
  },
  "return-statement": {
    "begin": "(?<!\\.)\\b(return)\\b",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.flow.return.qsharp"
      }
    },
    "end": "(?=;)"
    # TODO: inner patterns
    "patterns": [
      {
        "include": "#ref-modifier"
      },
      {
        "include": "#expression"
      }
    ]
  },
  "if-statement": {
    "begin": "(?<!\\.)\\b(if)|(elif)\\b\\s*(?=\\()",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.conditional.if.qsharp"
      },
      "2": {
        "name": "keyword.control.conditional.elif.qsharp"
      },
    },
    "end": "(?<=\\})",
    "patterns": [
      {
        "begin": "\\(",
        "beginCaptures": {
          "0": {
            "name": "punctuation.parenthesis.open.qsharp"
          }
        },
        "end": "\\)",
        "endCaptures": {
          "0": {
            "name": "punctuation.parenthesis.close.qsharp"
          }
        },
        "patterns": [
          {
            "include": "#expression"
          }
        ]
      },
      {
        "include": "#statement"
      }
    ]
  },
  "else-part": {
    "begin": "(?<!\\.)\\b(else)\\b",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.conditional.else.qsharp"
      }
    },
    "end": "(?<=\\})",
    "patterns": [
      {
        "include": "#statement"
      }
    ]
  },
  "for-statement": {
    "begin": "(?<!\\.)\\b(for)\\b\\s*(?=\\()",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.loop.for.qsharp"
      }
    },
    "end": "(?<=\\})", # TODO: No semicolon termination?
    "patterns": [
      {
        "begin": "\\(",
        "beginCaptures": {
          "0": {
            "name": "punctuation.parenthesis.open.qsharp"
          }
        },
        "end": "\\)",
        "endCaptures": {
          "0": {
            "name": "punctuation.parenthesis.close.qsharp"
          }
        },
        "patterns": [
          {
            # TODO: test thoroughly; compare C# `foreach`
            "match": "\\s*([_[:alpha:]][_[:alnum:]]*)\\s+(in)\\s+",
            "captures": {
              "1": {
                "name": "entity.name.variable.local.qsharp"
              },
              "2": {
                "name": "keyword.control.loop.in.qsharp"
              },
              # "3": {
              # # TODO: a capture for the range expression
              # }
              # TODO: a pattern for the statement block (loop body)?
            }
          }
        ]
      },
    ]
  },
  "repeat-statement": {
    "begin": "(?<!\\.)\\b(repeat)\\b",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.loop.repeat.qsharp"
      }
    },
    "end": "(?=;|})",  # TODO: should semicolons be allowed?
    "patterns": [
      {
        "include": "#statement"
      }
    ]
  },
  "until-statement": {
    "begin": "(?<!\\.)\\b(until)\\b\\s*",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.loop.until.qsharp"
      }
    },
    "end": "(?<!\\.)\\b(fixup)\\b\\s*",  # TODO: what about the fixup block?
    "endCaptures": {
      "1": {
        # TODO: Should `fixup` be captured in its own statement, "begin"?
        "name": "keyword.control.loop.fixup.qsharp"
      }
    }
    "patterns": [
      {
        "include": "#expression"  # TODO: enforce boolean expression?
      }
    ]
  },
  "fail-statement": {
    "begin": "(?<!\\.)\\b(fail)\\b",
    "beginCaptures": {
      "1": {
        "name": "keyword.control.flow.fail.qsharp"
      }
    },
    "end": "(?=;)",
    "patterns": [
      {
        "include": "#expression"
      }
    ]
  },
  "storage-modifiers": {
    "patterns": [
      {
        "name": "storage.modifiers.let.qsharp",
        "match": "(?<!\\.)\\b(let)\\b"
      },
      {
        "name": "storage.modifiers.mutable.qsharp",
        "match": "(?<!\\.)\\b(mutable)\\b"
      },
      {
        "name": "storage.modifiers.set.qsharp",
        "match": "(?<!\\.)\\b(set)\\b"
      }
    ]
  },
}
